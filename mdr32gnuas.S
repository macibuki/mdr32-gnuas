
.ttl "Milandr MDR32F9Q2I GNU AS assembler template"
.sbttl "Copyright © Д.А.Жижелев, авторский сайт: http://gimmor.blogspot.com/"
	@ Пример минимального начального ассемблерного файла для микроконтроллера, с комментариями
	@ Микроконтроллер: Миландр MDR32F9Q2I, 32-бит, ARM Cortex-M3
	@ Сайт производителя: http://milandr.ru/
	@ Язык ассемблера - UAL для ассемблера GNU AS, из набора инструментов GNU
	@ Мигание светодиодом, подключенным к порту PA.1
	@ Отладочная плата: MDR32-Solo, http://gimmor.blogspot.com/2013/03/mdr32-solo-mdr32f9q2i.html
	@ Простейший пример, когда микроконтроллер работает на встроённом 8МГц RC-генераторе,
	@ затем включается внешний кварцевый генератор (в моём случае 12 МГц)
	@ Сопутствующая заметка: http://gimmor.blogspot.com/2013/03/mdr32f9q2i-arm-gnu-as-example.html
	@ Файл предоставлен без каких-либо гарантий, для информационных целей. Применение на свой страх и риск.
	@ PLL не используется, оставлено для дальнейшей "копки"

.syntax unified

@ .text - секция исходного кода
.section .text




@ MOV32 - макрокоманда, аналогичная псевдокоманде MOV32 из ассемблера ARMASM
.macro    MOV32 regnum,number
     MOVW \regnum,:lower16:\number
     MOVT \regnum,:upper16:\number
.endm


.thumb


@ Ниже идут определения адресов регистров и пр., полученные из спецификации на микроконтроллер

@ Адрес стэка (стопки)
.equ STACK_TOP, 	0x20000100

@ Определение базового адреса блока управления системой SCB
.equ MDR_SCB, 		0xE000ED00

@ Смещение регистра идентификации процессора, относительно адреса MDR_SCB
@ Регистр доступен для чтения
@ У микроконтроллера Миландр MDR32F9Q2I, содержиться значение 0x412FC230 - оно общее для семейства мк 1986
.equ MDR_SCB_CPUID, 0x0
@ Значение CPUID
.equ MDR32F9Q2I_CPUID, 	0x412FC230


@ Батарейный домен MDR_BKP
.equ MDR_BKP, 		0x400D8000

@ Смещения регистров батарейного домена
.equ REG_OE, 		0x38
@ REG_0F Содержит информацию о готовности некоторых тактовых генераторов
.equ REG_0F, 		0x3C

@ Маска для проверки готовности внутреннего HSI-генератора


@ Определения адреса блока тактовых частот
.equ MDR_RST_CLK, 	0x40020000

@ Смещения регистров
.equ CLOCK_STATUS, 	0x00		@ CLOCK_STATUS - регистр состояния работы внешнего HSE генератора, PLL, USB PLL
.equ HS_CONTROL, 	0x08		@ HS_CONTROL - регистр управления внешним тактовым генератором HSE
.equ PER_CLOCK, 	0x1C		@ PER_CLOCK - регистр включения тактирования периферии
.equ CPU_CLOCK,		0x0C		@ CPU_CLOCK - регистр настройки тактирования CPU
.equ PLL_CONTROL, 	0x04		@ Регистр умножения частоты


@ Адреса регистров
.equ MDR_RST_CLK_PER_CLOCK, MDR_RST_CLK + PER_CLOCK

@ Маска внешнего HSE генератора
.equ MDR_HSE_ON, 	0x1

@ Маска для регистра CPU_CLOCK
.equ MDR_CPU_CLOCK, 	0x102
.equ MDR_CPU_CLOCK_HSE, 0x82

@ Маска для регистра PLL_CONTROL
@ Состояние битов см. спецификацию, таблицу 82
@ 0x504 - умножитель на 5 + 1 и включении
.equ MDR_CPU_PLL, 	0x0504
@ Бит №2 - бит выбор источника для CPU_C2
.equ MDR_ADD_PPLON, 0x04

@ Маски для включения периферии
.equ MDR_PORTA_EN,	0x00200000	@ Маска включения тактирования порта A
.equ MDR_BKP_EN, 	0x08000000	@ Маска включения тактирования батарейного домена



@ Определения порта A.
@ Адреса конфигурационных регистров порта A
.equ MDR_PORTA, 	0x400A8000
@ Смещения регистров порта (любого), относительно базового адреса
.equ PORT_FUNCTION, 0x08
.equ PORT_ANALOG, 	0x0C
.equ PORT_OE, 		0x04
.equ PORT_PWR, 		0x18
.equ PORT_RXTX, 	0x00
.equ PORT_PD, 		0x14

@ Маски значений для конфигурационных регистров порта A.
@ Значения зададим в шестнадцатеричной форме, их получим из бинарного представления с помощью калькулятора в операционной системе

.equ FUNC_A1,		0x00		@ Режим порта - 00 - выводы не переопределены и действуют как обычный порт
.equ ANALOG_A1, 	0x02		@ Выбран - цифровой
.equ OE_A1, 		0x02		@ Бит выхода
.equ RXTX_A1, 		0x02		@ Бит данных
.equ PWR_A1, 		0x0C 		@ PWR 11 (C) - максимальный фронт, биты 2-3 относятся к порту A.1




@ Это урезанная таблица векторов прерываний
.global _start
.type main, %function

_start:

.word STACK_TOP					@ указатель (адрес) стека
.word main + 1					@ обязательно добавить + 1


@ Метка Start - начало программы - реализация вектора входа по RESET. Сюда указывает второй адрес (вектор) таблицы прерываний
main:

@ Определим идентификацию процессора
@ В принципе про отладке через J-Link JTAG, в регистр R4 попадет CPUID нашего микроконтроллера
MOV32 R3, MDR_SCB
LDR R4, [R3, #MDR_SCB_CPUID] 	@ В регистр R4 заносим значение регистра MDR_SCB_CPUID, исп. базовый адрес из регистра R3

@ Тестовая работа с тактовой подсистемой
MOV32 R3, MDR_RST_CLK

@ Включение тактирования всей периферии
@ Данная операция обязательна, без неё не работают порты
LDR R4, [R3, #PER_CLOCK] 		@ MDR_RST_CLK_PER_CLOCK
ORR R4, #MDR_PORTA_EN 			@ Включаем только порт, батарейный домени и подсистему тактования
ORR R4, #MDR_BKP_EN				@ Включаем тактирование батарейного домена
STR R4, [R3, #PER_CLOCK] 		@ Сохраняем новое значение регистра R4, по адресу, вычисленному из R3 и смещения


@ Посмотрим, включён ли внутренний HSI генератор, а также посмотрим отпаянный "часовой" кварц
MOV32 R3, MDR_BKP
LDR R4, [R3,#REG_0F]
@ По результатам первого запуска в регистре содержится 0
@ По идее, должен быть включен внутренний генератор, а он выглядит выключенным
@ Предположение о том, что должна быть включена тактовая частота батарейного домена подтвердилась
@ Маска готовности HSI - 0x00C00000 (22 и 23 биты)
@ Также видно, что отключен LSE, не работает и LSI, что странно, в спецификации указано, что он запускается
@ при подаче питания



@ Теперь предварительно посмотрим состояние регистра MDR_RST_CLK_CPU_CLOCK, отвечающего за внешний кварцевый генератор
@ Генератор HSE запускается при появлении питания UCC и сигнала разрешения HSEON в регистре HS_CONTROL.
@ При выходе в нормальный режим работы вырабатывает сигнал HSERDY в регистре CLOCK_STATUS.


@ Работа с тактовой подсистемой
MOV32 R3, MDR_RST_CLK
@ Смотрим, в отладчике, исходное состояние регистра  MDR_RST_CLK_CLOCK_STATUS
LDR R4, [R3, #CLOCK_STATUS] 	@ MDR_RST_CLK_CLOCK_STATUS
@ Важны первые 3 бита,
@ Нули свидетельствуют о том, что HSE выключен, PLL выключена, USB PLL выключена


@ Включение внешнего кварцевого генератора
LDR R4, [R3, #HS_CONTROL] 		@ MDR_RST_CLK_HS_CONTROL - простой регистр
ORR R4, #MDR_HSE_ON 			@ Бит включения внешнего кварцевого генератора
STR R4, [R3, #HS_CONTROL] 		@ Сохраняем новое значение регистра R4, по адресу, вычисленному из R3 и смещения

@ Теперь надо подождать выхода генератора в рабочий режим
@ Можно конечно и цикл организовать, но на этапе шаблона - лишнее это
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP

LDR R4, [R3, #CLOCK_STATUS] 	@ Посмотреть в отладчике регистр MDR_RST_CLK_CLOCK_STATUS



@ СPU_CLOCK
LDR R4, [R3, #CPU_CLOCK] 		@ MDR_RST_CLK_CPU_CLOCK
ORR R4, #MDR_CPU_CLOCK_HSE 		@ Маска включения HSE в качестве тактового генератора CPU
STR R4, [R3, #CPU_CLOCK] 		@ Сохраняем новое значение регистра R4, по адресу, вычисленному из R3 и смещения

//TODO

@ Теперь можно проверить возможности блока PLL
@	LDR R4, [R3, #PLL_CONTROL]
@	ORR R4, #0x500
@	ORR R4, #0x04
@	STR R4, [R3, #PLL_CONTROL]
@	ORR R4, #0x0C
@	STR R4, [R3, #PLL_CONTROL]
@	MOV R4,#0
@	ORR R4, #0x500
@	ORR R4, #0x04
@	STR R4, [R3, #PLL_CONTROL]

@ORR R4, #MDR_CPU_PLL # Маска включения PLL и настройки множителя
@STR R4, [R3, #PLL_CONTROL]

@ Теперь дожидаемся выхода на устойчивый режим PLL
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
LDR R4, [R3, #CLOCK_STATUS] 	@ MDR_RST_CLK_CLOCK_STATUS



@ И обновить CPU_CLOCK
@	LDR R4, [R3, #CPU_CLOCK] 	@ MDR_RST_CLK_CPU_CLOCK
@	ORR R4, #0x106 				@ Маска добавления PLL
@	STR R4, [R3, #CPU_CLOCK] 	@ Сохраняем новое значение регистра R4, по адресу, вычисленному из R3 и смещения


NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP






@ Начальная конфигурация линии №1 порта A. (PA.1)
MOV32 R3, MDR_PORTA 			@ Загрузить базовый 32-битный адрес порта A в регистр. Используется псевдоинструкция MOV32
LDR R4, [R3, #PORT_FUNCTION] 	@ Загрузить в регистр R4, значение заданное базовым адресом в регистре R3 и смещением (0x08), в данном случае, содержимое регистра порта A, MDR_PORTA_FUNC
LDR R5, [R3, #PORT_ANALOG] 		@ Загрузить в регистр R5, значение заданное базовым адресом в регистре R3 и смещением (0x0C), в данном случае, содержимое регистра порта A, MDR_PORTA_ANALOG
LDR R6, [R3, #PORT_OE] 			@ Загрузить в регистр R6, значение заданное базовым адресом в регистре R3 и смещением (0x04), в данном случае, содержимое регистра порта A, MDR_PORTA_OE
LDR R7, [R3, #PORT_PWR] 		@ Загрузить в регистр R7, значение заданное базовым адресом в регистре R3 и смещением (0x18), в данном случае, содержимое регистра порта A, MDR_PORTA_OE

@ Наложение масок
ORR R4, #FUNC_A1
ORR R5, #ANALOG_A1
ORR R6, #OE_A1
ORR R7, #PWR_A1

@ Выгрузка значений регистров общего назначения, в память регистров порта
STR R4, [R3, #PORT_FUNCTION] 	@ Выгрузить из регистра R4, в память с адресом, значение которого задано базовым адресом в регистре R3 и смещением (0x08), в данном случае, содержимое регистра порта A, MDR_PORTA_FUNC
STR R5, [R3, #PORT_ANALOG] 		@ Выгрузить из регистра R5, в память с адресом, значение которого задано базовым адресом в регистре R3 и смещением (0x0C), в данном случае, содержимое регистра порта A, MDR_PORTA_ANALOG
STR R7, [R3, #PORT_PWR] 		@ Выгрузить из регистра R6, в память с адресом, значение которого задано базовым адресом в регистре R3 и смещением (0x04), в данном случае, содержимое регистра порта A, MDR_PORTA_OE
STR R6, [R3, #PORT_OE] 			@ Выгрузить из регистра R6, в память с адресом, значение которого задано базовым адресом в регистре R3 и смещением (0x04), в данном случае, содержимое регистра порта A, MDR_PORTA_OE


@ Просмотр состояния ( в режиме отладки)
LDR R4, [R3, #PORT_FUNCTION] 	@ Загрузить в регистр R4, значение заданное базовым адресом в регистре R3 и смещением (0x08), в данном случае, содержимое регистра порта A, MDR_PORTA_FUNC
LDR R5, [R3, #PORT_ANALOG] 		@ Загрузить в регистр R5, значение заданное базовым адресом в регистре R3 и смещением (0x0C), в данном случае, содержимое регистра порта A, MDR_PORTA_ANALOG
LDR R6, [R3, #PORT_OE] 			@ Загрузить в регистр R6, значение заданное базовым адресом в регистре R3 и смещением (0x04), в данном случае, содержимое регистра порта A, MDR_PORTA_OE
LDR R7, [R3, #PORT_PWR] 		@ Загрузить в регистр R7, значение заданное базовым адресом в регистре R3 и смещением (0x18), в данном случае, содержимое регистра порта A, MDR_PORTA_OE

@ Бесконечный цикл - моргание светодиодом
loop:

@ Установить линию в лог. 0 - в моём случае включить светодиод
LDR R4, [R3, #PORT_RXTX] 		@ Загрузить в регистр R4, значение заданное базовым адресом в регистре R3 и смещением (0x00), в данном случае, содержимое регистра порта A, MDR_PORTA_RXTX
BIC R4, #RXTX_A1				@ Сброс бита по маске
STR R4, [R3, #PORT_RXTX] 		@ Выгрузить из регистра R4, в память с адресом, значение которого задано базовым адресом в регистре R3 и смещением 0x00
LDR R4, [R3, #PORT_RXTX] 		@ Загрузить в регистр R4, значение заданное базовым адресом в регистре R3 и смещением (0x00), в данном случае, содержимое регистра порта A, MDR_PORTA_RXTX

@ Пауза
MOV32 R0, 2000000				@ Счёт

delay:


SUB R0, #1						@ Декремент, результат сохраняется в R0
CMP R0, #0
BNE delay

@ Установить линию в лог. 1 - в моем случае выключить светодиод
LDR R4, [R3, #PORT_RXTX] 		@ Загрузить в регистр R4, значение заданное базовым адресом в регистре R3 и смещением (0x00), в данном случае, содержимое регистра порта A, MDR_PORTA_RXTX
ORR R4, #RXTX_A1
STR R4, [R3, #PORT_RXTX] 		@ Выгрузить из регистра R4, в память с адресом, значение которого задано базовым адресом в регистре R3 и смещением 0x00

@ Пауза
MOV32 R0, 2000000				@ 8000000 / 4 такта Счёт

delay2:
	SUB R0, #1					@ Декремент, результат сохраняется в R0
	CMP R0, #0					@ Сравнение с 0
	BNE delay2					@ Если не равно 0, то продолжаем держать паузу


B loop




# Конец файла
.end
